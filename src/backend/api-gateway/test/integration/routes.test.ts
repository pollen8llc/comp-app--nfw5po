import supertest from 'supertest';
import { jest } from '@jest/globals';
import { Router } from 'express';
import { authenticate } from '../../src/middleware/auth';
import { setupTestDatabase, teardownTestDatabase, createTestMember, createTestEvent } from '../../../test/utils/test-helpers';
import { ERROR_CODES } from '../../../shared/utils/error-codes';
import { TDAParameters, DistanceMetric } from '../../../shared/types/analytics.types';
import { Member } from '../../../shared/types/member.types';
import { Event } from '../../../shared/types/event.types';

// Initialize test app and request client
const testApp = express();
const request = supertest(testApp);

// Test data
let testMember: Member;
let testEvent: Event;
let validToken: string;

describe('API Gateway Routes Integration Tests', () => {
  beforeAll(async () => {
    // Setup test environment
    await setupTestDatabase();
    
    // Mount routes with authentication
    const router = Router();
    router.use(authenticate);
    testApp.use('/api/v1', router);

    // Create test data
    testMember = await createTestMember();
    testEvent = await createTestEvent();
    validToken = 'valid-test-token'; // Would be generated by auth service
  });

  afterAll(async () => {
    await teardownTestDatabase();
  });

  describe('Authentication & Authorization', () => {
    it('should reject requests without authentication token', async () => {
      const response = await request.get('/api/v1/members');
      
      expect(response.status).toBe(401);
      expect(response.body.error.code).toBe(ERROR_CODES.AUTHENTICATION_ERROR);
    });

    it('should reject requests with invalid token', async () => {
      const response = await request
        .get('/api/v1/members')
        .set('Authorization', 'Bearer invalid-token');
      
      expect(response.status).toBe(401);
      expect(response.body.error.code).toBe(ERROR_CODES.AUTHENTICATION_ERROR);
    });

    it('should allow requests with valid token', async () => {
      const response = await request
        .get('/api/v1/members')
        .set('Authorization', `Bearer ${validToken}`);
      
      expect(response.status).toBe(200);
    });
  });

  describe('Rate Limiting', () => {
    it('should enforce rate limits', async () => {
      const requests = Array(101).fill(null).map(() => 
        request
          .get('/api/v1/members')
          .set('Authorization', `Bearer ${validToken}`)
      );

      const responses = await Promise.all(requests);
      const rateLimitedResponse = responses[responses.length - 1];

      expect(rateLimitedResponse.status).toBe(429);
      expect(rateLimitedResponse.body.error.code).toBe(ERROR_CODES.RATE_LIMIT_ERROR);
    });

    it('should include rate limit headers', async () => {
      const response = await request
        .get('/api/v1/members')
        .set('Authorization', `Bearer ${validToken}`);

      expect(response.headers['x-ratelimit-limit']).toBeDefined();
      expect(response.headers['x-ratelimit-remaining']).toBeDefined();
      expect(response.headers['x-ratelimit-reset']).toBeDefined();
    });
  });

  describe('Member Routes', () => {
    it('should create member with valid data', async () => {
      const memberData = {
        profile: {
          name: 'Test User',
          email: 'test@example.com',
          role: 'MEMBER'
        },
        socialProfiles: [{
          platform: 'LINKEDIN',
          externalId: '12345',
          verified: true
        }]
      };

      const response = await request
        .post('/api/v1/members')
        .set('Authorization', `Bearer ${validToken}`)
        .send(memberData);

      expect(response.status).toBe(201);
      expect(response.body.data.profile.email).toBe(memberData.profile.email);
    });

    it('should validate member data', async () => {
      const invalidData = {
        profile: {
          name: '', // Invalid: empty name
          email: 'invalid-email' // Invalid: wrong format
        }
      };

      const response = await request
        .post('/api/v1/members')
        .set('Authorization', `Bearer ${validToken}`)
        .send(invalidData);

      expect(response.status).toBe(400);
      expect(response.body.error.code).toBe(ERROR_CODES.VALIDATION_ERROR);
    });
  });

  describe('Event Routes', () => {
    it('should create event with valid data', async () => {
      const eventData = {
        title: 'Test Event',
        description: 'Test Description',
        start_date: new Date(),
        end_date: new Date(Date.now() + 86400000),
        location: 'Test Location'
      };

      const response = await request
        .post('/api/v1/events')
        .set('Authorization', `Bearer ${validToken}`)
        .send(eventData);

      expect(response.status).toBe(201);
      expect(response.body.data.title).toBe(eventData.title);
    });

    it('should validate event data', async () => {
      const invalidData = {
        title: '', // Invalid: empty title
        start_date: 'invalid-date' // Invalid: wrong format
      };

      const response = await request
        .post('/api/v1/events')
        .set('Authorization', `Bearer ${validToken}`)
        .send(invalidData);

      expect(response.status).toBe(400);
      expect(response.body.error.code).toBe(ERROR_CODES.VALIDATION_ERROR);
    });
  });

  describe('Analytics Routes', () => {
    it('should compute TDA with valid parameters', async () => {
      const tdaParams: TDAParameters = {
        epsilon: 0.5,
        minPoints: 15,
        dimension: 2,
        persistenceThreshold: 0.3,
        distanceMetric: DistanceMetric.EUCLIDEAN
      };

      const response = await request
        .post('/api/v1/analytics/tda')
        .set('Authorization', `Bearer ${validToken}`)
        .send(tdaParams);

      expect(response.status).toBe(200);
      expect(response.body.data).toBeDefined();
    });

    it('should validate TDA parameters', async () => {
      const invalidParams = {
        epsilon: 2.0, // Invalid: out of range
        minPoints: 0, // Invalid: too low
        dimension: 4 // Invalid: unsupported dimension
      };

      const response = await request
        .post('/api/v1/analytics/tda')
        .set('Authorization', `Bearer ${validToken}`)
        .send(invalidParams);

      expect(response.status).toBe(400);
      expect(response.body.error.code).toBe(ERROR_CODES.VALIDATION_ERROR);
    });
  });

  describe('Graph Routes', () => {
    it('should execute graph query within time limit', async () => {
      const queryData = {
        queryPattern: 'MATCH (m:Member) RETURN m LIMIT 10',
        parameters: {},
        limit: 10
      };

      const startTime = Date.now();
      const response = await request
        .post('/api/v1/graph/query')
        .set('Authorization', `Bearer ${validToken}`)
        .send(queryData);
      const duration = Date.now() - startTime;

      expect(response.status).toBe(200);
      expect(duration).toBeLessThan(2000); // Sub-2 second requirement
    });

    it('should validate graph query complexity', async () => {
      const complexQuery = {
        queryPattern: 'MATCH (m:Member)-[*5..10]->(n) RETURN m,n', // Too complex
        parameters: {},
        limit: 1000 // Too high
      };

      const response = await request
        .post('/api/v1/graph/query')
        .set('Authorization', `Bearer ${validToken}`)
        .send(complexQuery);

      expect(response.status).toBe(400);
      expect(response.body.error.code).toBe(ERROR_CODES.VALIDATION_ERROR);
    });
  });

  describe('Security Headers', () => {
    it('should include security headers in responses', async () => {
      const response = await request
        .get('/api/v1/members')
        .set('Authorization', `Bearer ${validToken}`);

      expect(response.headers['x-content-type-options']).toBe('nosniff');
      expect(response.headers['x-frame-options']).toBe('DENY');
      expect(response.headers['x-xss-protection']).toBe('1; mode=block');
    });
  });

  describe('Error Handling', () => {
    it('should handle internal server errors gracefully', async () => {
      // Mock internal error
      jest.spyOn(console, 'error').mockImplementation(() => {});
      
      const response = await request
        .get('/api/v1/members/invalid-id')
        .set('Authorization', `Bearer ${validToken}`);

      expect(response.status).toBe(500);
      expect(response.body.error.code).toBe(ERROR_CODES.INTERNAL_SERVER_ERROR);
    });

    it('should handle validation errors with details', async () => {
      const invalidData = {
        profile: {
          email: 'invalid'
        }
      };

      const response = await request
        .post('/api/v1/members')
        .set('Authorization', `Bearer ${validToken}`)
        .send(invalidData);

      expect(response.status).toBe(400);
      expect(response.body.error.code).toBe(ERROR_CODES.VALIDATION_ERROR);
      expect(response.body.error.details).toBeDefined();
    });
  });
});